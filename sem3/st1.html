<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Unit-01 | ST | SOUNotes</title>
    <link rel="stylesheet" href="../assets/css/global.css" />
    <link rel="stylesheet" href="assets/css/sem3.css" />
    <link
      rel="shortcut icon"
      href="assets/img/favicon.png"
      type="image/x-icon"
    />
    <style>
      strong {
        color: #8c75ea;
      }
    </style>
  </head>
  <body>
    <nav>
      <a href="../about.html"
        ><img
          class="menubar"
          src="assets/img/favicon.png"
          alt="menu"
          height="28px"
      /></a>
      <a class="logo" href="../index.html">SOU BCA Notes</a>
      <a id="theme-toggle" onclick="modeSwitcher()">
        <img
          class="dlmode"
          id="theme-image"
          src="assets/img/light.png"
          alt="mode"
          height="28px"
      /></a>
    </nav>
    <div id="breadcrumbs">
      <a href="../index.html"><u>Home</u></a
      >/ <a href="sem3.html"><u>Sem-III</u></a
      >/ <a href="sem3.html#tmp"><u>ST</u></a
      >/ <a href="tmp1.html"><u>01: Introduction</u></a
      >/
    </div>
    <main>
      <div class="toc">
        <center><b>Table of Content</b></center>
        <br />
        01: <u><a href="#head1">Introduction</a><br /></u> 02:
        <u><a href="#head2">Approaches of Testing</a><br /></u> 03:
        <u><a href="#head3">Testing During SDLC</a><br /></u>
        04:
        <u><a href="#head4">Requirement Traceability Matrix</a><br /></u> 05:
        <u><a href="#head5">Essentials of Software Testing</a><br /></u> 06:
        <u><a href="#head6">Principles of Software Testing</a><br /></u> 07:
        <u><a href="#head7">Importance of Software Testing</a><br /></u> 08:
        <u><a href="#head8">Process Problems Faced by Testing</a><br /></u> 09:
        <u><a href="#head9">Software Testing Terminology</a><br /></u> 10:
        <u><a href="#head10">Software Testing Life Cycle</a><br /></u> 11:
        <u><a href="#head11">Benefits of STLC</a><br /></u> 12:
        <u><a href="#head12">Software Testing Methodology</a><br /></u> 12.01:
        <u><a href="#heada">Waterfall Method</a><br /></u> 12.02:
        <u><a href="#headb">Agile Testing</a><br /></u> 12.03:
        <u><a href="#headc">DevOps Testing</a><br /></u> 13:
        <u><a href="#head13">Verification & Validation</a><br /></u>
      </div>
      <div class="page">
        <h1 id="head1">Introduction</h1>
        <br />
        <ul>
          <li>
            Software testing is the process of evaluating a software program to
            find bugs, verify it meets expectations, and ensure it functions as
            intended.
          </li>
          <li>
            It&#39;s a crucial part of the software development lifecycle.
          </li>
          <li>
            Software testing aims to deliver a polished, high-quality product
            that meets user requirements and expectations.
          </li>
        </ul>
        <br /><br />
        <h1 id="head2">Approaches of Testing</h1>
        <br />
        <ul>
          <li>
            There are two main approaches to testing:
            <ul>
              <li>
                A <strong>human tester</strong> interacts with the software to
                assess its functionality.
              </li>
              <li>
                Testers use scripts or tools to
                <strong>automate</strong> repetitive tasks, saving time and
                effort.
              </li>
            </ul>
          </li>
        </ul>
        <br /><br />
        <h1 id="head3">Testing During SDLC</h1>
        <br />
        <div class="images">
          <img src="assets/img/1st01.png" width="90%" />
        </div>
        <ul>
          <li>
            <strong>Requirements Analysis</strong>: Testers are involved early
            on to understand the software&#39;s purpose, functionalities, and
            user needs. This helps identify potential testing areas and ensure
            requirements are clear and testable.
          </li>
          <li>
            <strong>Design Phase</strong>: Testers collaborate with designers to
            review the software&#39;s architecture and identify potential design
            flaws that could lead to testing challenges later.
          </li>
          <li>
            <strong>Unit Testing</strong>: Individual software units (modules)
            are tested by developers to ensure they function as designed.
          </li>
          <li>
            <strong>Integration Testing:</strong> Once units are tested,
            they&#39;re integrated to form a larger system. Testers verify if
            these integrated components work seamlessly together.
          </li>
          <li>
            <strong>System Testing:</strong> The entire software application is
            tested as a whole to ensure it meets all functional and
            non-functional requirements (performance, usability, etc.).
          </li>
          <li>
            <strong>Acceptance Testing:</strong> Real users or potential
            customers test the software to provide feedback on its usability and
            functionality from an end-user perspective. This helps identify any
            user interface or experience issues.
          </li>
        </ul>
        <br /><br />
        <h1 id="head4">Requirement Traceability Matrix</h1>
        <br />
        <ul>
          <li>
            A Requirement Traceability Matrix (RTM), also known as a
            <strong>Cross-Reference Matrix (CRM)</strong>, is a table-like
            document used in software development and other fields to track the
            relationships between different project artifacts.
          </li>
          <li>
            It essentially creates a map that shows how requirements are
            implemented and verified throughout the development process.
          </li>
          <br />
          <h4 id="benefits-of-using-rtm-">Benefits of using RTM:</h4>
          <li>
            <strong>Improved Verification and Validation:</strong> Ensures all
            requirements are addressed by design and testing processes.
          </li>
          <li>
            <strong>Enhanced Impact Analysis:</strong> Helps understand how
            changes to a requirement affect other parts of the project.
          </li>
          <li>
            <strong>Stronger Project Management:</strong> Provides a centralized
            view of project progress and potential issues.
          </li>
          <li>
            <strong>Efficient Change Management:</strong> Simplifies tracking
            the impact of changes on related deliverables.
          </li>
          <li>
            <strong>Improved Verification and Validation:</strong> Ensures all
            requirements are addressed by design and testing processes.
          </li>
          <li>
            <strong>Enhanced Impact Analysis:</strong> Helps understand how
            changes to a requirement affect other parts of the project.
          </li>
          <li>
            <strong>Stronger Project Management:</strong> Provides a centralized
            view of project progress and potential issues.
          </li>
          <li>
            <strong>Efficient Change Management:</strong> Simplifies tracking
            the impact of changes on related deliverables.
          </li>
        </ul>
        <br /><br />
        <h1 id="head5">Essentials of Software Testing</h1>
        <br />
        <ul>
          <strong>Robust Testing Strategy:</strong>
          <li>
            This high-level plan outlines the overall testing approach for the
            project.
          </li>
          <li>
            It defines what types of testing will be conducted (functional,
            performance, etc.), the order of testing, and the resources needed.
          </li>
          <li>
            A well-defined strategy ensures a targeted and efficient testing
            effort.
          </li>
          <br />
          <strong>Detailed Testing Plan:</strong>
          <li>
            This plan dives deeper into specifics, outlining the individual test
            cases that will be executed.
          </li>
          <li>
            Each test case should map back to specific requirements to ensure
            comprehensive coverage.
          </li>
          <li>
            The plan should also include details on the testing environment,
            data required, and expected results.
          </li>
          <br />
          <strong>Well-designed Test Cases:</strong>
          <li>Effective test cases are the backbone of thorough testing.</li>
          <li>
            They should be clear, concise, and cover a wide range of scenarios,
            including positive and negative test cases.
          </li>
          <li>
            Strong test cases help identify defects and edge cases that might
            otherwise be missed.
          </li>
          <br />
          <strong>Relevant Test Data:</strong>
          <li>
            The quality of your test data significantly impacts the
            effectiveness of testing.
          </li>
          <li>
            You&#39;ll need a variety of data sets to simulate real-world usage
            and expose potential issues.
          </li>
          <li>This may include valid, invalid, and boundary value data.</li>
          <br />
          <strong>Ideal Testing Environment:</strong>
          <li>
            A stable and reliable testing environment is crucial for accurate
            and repeatable test results.
          </li>
          <li>
            The environment should mirror the production environment as closely
            as possible to avoid surprises when the software is deployed.
          </li>
          <br />
          <strong>Defect Tracking and Reporting:</strong>
          <li>
            A system for logging and tracking discovered defects is essential.
          </li>
          <li>
            This allows testers to document issues, prioritize them based on
            severity, and track their resolution throughout the development
            process.
          </li>
          <br />
          <strong>Testing Expertise and Skills:</strong>
          <li>
            Effective testing requires a skilled team with a deep understanding
            of testing methodologies, tools, and best practices.
          </li>
          <li>
            Testers should be able to analyse requirements, design test cases,
            and think critically to uncover potential issues.
          </li>
          <br />
          <strong>Communication and Collaboration:</strong>
          <li>
            Throughout the testing process, clear communication and
            collaboration between testers, developers, and other stakeholders
            are essential.
          </li>
          <li>
            This ensures everyone is aware of identified issues and works
            together to resolve them effectively.
          </li>
        </ul>
        <br /><br />
        <h1 id="head6">Principles of software testing:</h1>
        <br />
        <ul>
          <li>
            <strong>Testing Shows Presence of Defects, Not Absence:</strong>
            Testing aims to uncover bugs and malfunctions, not definitively
            prove software is flawless.
          </li>
          <li>
            <strong>Early Testing Saves Time and Money:</strong> Identifying
            defects early in the development lifecycle is much cheaper and
            easier to fix than waiting until later stages.
          </li>
          <li>
            <strong>Defect Clustering:</strong> The Pareto Principle (80/20
            rule) often applies in software testing.
          </li>
          <li>
            <strong>Pesticide Paradox:</strong> Repeatedly using the same tests
            with minor variations may not uncover new defects.
          </li>
          <li>
            <strong>Testing is Context-Dependent:</strong> The testing strategy
            should be tailored to the specific software, its intended use, and
            the project&#39;s priorities.
          </li>
          <li>
            <strong>Absence of Errors Fallacy:</strong> Finding no defects
            during testing doesn&#39;t guarantee a perfect product.
          </li>
        </ul>
        <br /><br />
        <h1 id="head7">Importance of software testing:</h1>
        <br />
        <ul>
          <li>
            <strong>Improved Software Quality:</strong> Testing helps identify
            and fix bugs, leading to a more robust, reliable, and user-friendly
            product.
          </li>
          <li>
            <strong>Reduced Risk of Failure:</strong> By proactively uncovering
            issues, testing minimizes the risk of software failures after
            deployment.
          </li>
          <li>
            <strong>Enhanced Security:</strong> Testing helps identify security
            vulnerabilities that could be exploited by attackers.
          </li>
          <li>
            <strong>Pesticide Paradox:</strong> Repeatedly using the same tests
            with minor variations may not uncover new defects.
          </li>
          <li>
            <strong>Testing is Context-Dependent:</strong> The testing strategy
            should be tailored to the specific software, its intended use, and
            the project&#39;s priorities.
          </li>
          <li>
            <strong>Absence of Errors Fallacy:</strong> Finding no defects
            during testing doesn&#39;t guarantee a perfect product.
          </li>
        </ul>
        <br /><br />
        <h1 id="head8">Process Problems Faced by Testing</h1>
        <br />
        <ul>
          <li>
            <strong>Incomplete Requirements:</strong> Testers often face issues
            when requirements are not well-defined or are incomplete.
          </li>
          <li>
            <strong>Insufficient Test Planning:</strong> Poor test planning can
            lead to unorganized and ineffective testing efforts.
          </li>
          <li>
            <strong>Lack of Resources:</strong> Testing teams may lack the
            necessary resources, such as skilled personnel, tools, and
            environments.
          </li>
          <li>
            <strong>Inadequate Test Coverage:</strong> Use risk-based testing
            approaches to prioritize test cases and ensure critical areas are
            thoroughly tested.
          </li>
          <li>
            <strong>Time Constraint:</strong> Testing often gets squeezed at the
            end of the development cycle, leading to rushed testing.
          </li>
          <li>
            <strong>Communication Gaps:</strong> Foster open communication
            channels and use collaboration tools to improve information sharing.
          </li>
        </ul>
        <br /><br />
        <h1 id="head9">Software Testing Terminology</h1>
        <br />
        Software Testing terminology means
        <strong>collection of inputs and expected outputs</strong>
        <ul>
          <li>
            <strong>Failure:</strong> The inability of a system or component to
            perform a required function according to its specification.
          </li>
          <li>
            <strong>Fault / Defect / Bug:</strong> Fault is a condition that in
            actual causes a system to produce failure. It can be said that
            failures are manifestation of bugs.
          </li>
          <li>
            <strong>Error</strong>: When a developer or a team makes any mistake
            in any phase of SDLC, errors are produced. It might be a
            typographical error, a misleading of a specification, a
            misunderstanding of what a subroutine does and so on. Thus, error is
            a very general term used for human mistakes.
          </li>
          <li>
            <strong>Testware:</strong> The documents created during the testing
            activities are known as Testware.
          </li>
          <li>
            <strong>Incident:</strong> Any problem (such as queries, defect
            reports, or test script failures) that requires investigation by the
            test team.
          </li>
          <li>
            <strong>Test bed:</strong> Test bed is an environment where testers
            run their test cases. It includes hardware, software, network
            configuration, and other necessary elements for performing tests.
          </li>
          <li>
            <strong>Test Case:</strong> A test case is a set of actions and
            conditions used to verify a feature or functionality of a software
            application.
          </li>
          <li>
            <strong>Test Oracle</strong>: to judge the success or failure of a
            test
          </li>
        </ul>
        <br /><br />
        <h1 id="head10">STLC: Software Testing Life Cycle</h1>
        <br />
        <div class="images">
          <img src="assets/img/1st02.png" width="90%" />
        </div>
        <p>
          Software Testing Life Cycle (STLC) is a sequence of different
          activities performed by the testing team to ensure that the software
          product meets the quality standards. The phases are:
        </p>
        <ul>
          <li>
            <strong>Requirement Analysis:</strong> Testers are involved early on
            to understand the software&#39;s purpose, functionalities, and user
            needs. This helps identify potential testing areas and ensure
            requirements are clear and testable.
          </li>
          <li>
            <strong>Test Planning:</strong> A comprehensive plan is developed,
            outlining the testing strategy, scope, resources, schedule, and
            deliverables.
          </li>
          <li>
            <strong>Test Case Design and Development:</strong> Detailed test
            cases are designed based on requirements and test plans to validate
            specific functionalities.
          </li>
          <li>
            <strong>Test Environment Setup:</strong> The test environment is
            prepared to replicate the production environment, ensuring accurate
            test results.
          </li>
          <li>
            <strong>Test Execution:</strong> Test cases are executed, and
            results are documented to identify any discrepancies between
            expected and actual outcomes.
          </li>
          <li>
            <strong>Defect Reporting and Tracking:</strong> Any defects found
            are reported, and their resolution is tracked through to closure.
          </li>
          <li>
            <strong>Test Closure:</strong> Final test reports are generated,
            summarizing the testing process, results, and any lessons learned
            for future projects.
          </li>
        </ul>
        <br /><br />
        <h1 id="head11">Benefits of STLC:</h1>
        <br />
        <ul>
          <li>
            <strong>Improved Software Quality:</strong> STLC helps identify and
            fix bugs early in the development process, leading to a more robust
            and reliable software product.
          </li>
          <li>
            <strong>Reduced Development Costs:</strong> Fixing bugs later in the
            development cycle is expensive. STLC helps catch issues early,
            saving time and resources.
          </li>
          <li>
            <strong>Enhanced User Experience:</strong> By ensuring the software
            meets user requirements, STLC contributes to a more positive user
            experience.
          </li>
        </ul>
        <br /><br />
        <h1 id="head12">Software Testing Methodology</h1>
        <br />
        <div class="images">
          <img src="assets/img/1st03.png" width="90%" />
        </div>
        <ul>
          <li>
            Software testing methodology refers to the overall strategy and
            approach used to guide the software testing process. It defines how
            you&#39;ll achieve your testing goals, considering factors like
            project type, development lifecycle, and resources. There are
            several popular methodologies, each with its own strengths and
            weaknesses.
          </li>
          <br />
          <h4 id="heada">Waterfall Model:</h4>
          <br />
          <div class="images">
            <img src="assets/img/1st04.png" width="90%" />
          </div>
          <li>Traditional, sequential approach.</li>
          <li>Testing happens after development is complete.</li>
          <li>
            <strong>Pros</strong>: Well-defined phases, easy to manage for small
            projects.
          </li>
          <li>
            <strong>Cons</strong>: Inflexible, doesn&#39;t adapt to changes
            well. May miss bugs due to late testing.
          </li>
          <br />
          <h4 id="headb">Agile Testing</h4>
          <br />
          <div class="images">
            <img src="assets/img/1st05.png" width="90%" />
          </div>
          <li>Iterative and incremental approach.</li>
          <li>Testing happens alongside development in short sprints.</li>
          <li>
            <strong>Pros</strong>: Adaptable to changing requirements, faster
            feedback loop.
          </li>
          <li>
            <strong>Cons</strong>: Requires strong communication and
            collaboration between testers and developers. May require more
            automation for efficiency.
          </li>
          <br />
          <h4 id="headc">DevOps Testing</h4>
          <br />
          <div class="images">
            <img src="assets/img/1st06.png" width="90%" />
          </div>
          <li>
            Focuses on
            <strong>Continuous Integration and Continuous Delivery</strong>
            (CI/CD).
          </li>
          <li>Testing is integrated throughout the development pipeline.</li>
          <li>
            <strong>Pros</strong>: Fast feedback loop, promotes quality at every
            stage.
          </li>
          <li>
            <strong>Cons</strong>: Requires a strong automation strategy and
            cultural shift within teams.
          </li>
        </ul>
        <br /><br />
        <h1 id="head13">Verification & Validation</h1>
        <br />
        <div class="images">
          <img src="assets/img/1st07.png" width="90%" />
        </div>
        <ul>
          <h4 id="verification-">Verification:</h4>
          <br />
          <li>
            Verification is the process of checking that software achieves its
            goal without any bugs.
          </li>
          <li>
            It is the process to ensure whether the product that is developed is
            right or not.
          </li>
          <li>
            It verifies whether the developed product fulfils the requirements
            that we have.
          </li>
          <li>Verification is <strong>static</strong> testing.</li>
          <br />
          <h4 id="validation-">Validation:</h4>
          <br />
          <li>
            Validation is the process of checking whether the software product
            is up to the mark or in other words product has high-level
            requirements.
          </li>
          <li>
            It is the process of checking the validation of the product i.e. it
            checks what we are developing is the right product.
          </li>
          <li>It is validation of the actual and expected products.</li>
          <li>Validation is <strong>dynamic</strong> test.</li>
        </ul>
        <br />
      </div>
    </main>
    <a class="dlbtn" href="assets/pdfs/ST01.pdf"
      ><img src="assets/img/download.png" height="50px"
    /></a>
    <div class="end">
      <div class="footer">
        <p>
          Made by <a href="../about.html"><u>SOU Student</u></a> For SOU
          Students
        </p>
      </div>
    </div>
    <script src="../assets/js/global.js"></script>
  </body>
</html>
