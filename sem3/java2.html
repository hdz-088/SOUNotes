<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Unit-02 | Java | SOUNotes</title>
    <link rel="stylesheet" href="../assets/css/global.css" />
    <link rel="stylesheet" href="assets/css/sem3.css" />
    <link rel="stylesheet" href="assets/css/prism.css" />
    <link
      rel="shortcut icon"
      href="assets/img/favicon.png"
      type="image/x-icon"
    />
    <style>
      strong {
        color: #db380e;
      }
    </style>
  </head>
  <body>
    <nav>
      <a href="../about.html"
        ><img
          class="menubar"
          src="assets/img/favicon.png"
          alt="menu"
          height="28px"
      /></a>
      <a class="logo" href="../index.html">SOU BCA Notes</a>
      <a id="theme-toggle" onclick="modeSwitcher()">
        <img
          class="dlmode"
          id="theme-image"
          src="assets/img/light.png"
          alt="mode"
          height="28px"
      /></a>
    </nav>
    <div id="breadcrumbs">
      <a href="../index.html"><u>Home</u></a
      >/ <a href="sem3.html"><u>Sem-III</u></a
      >/ <a href="sem3.html#java"><u>Java</u></a
      >/ <a href="java1.html"><u>02 Array, Inheritance and Interface</u></a
      >/
    </div>
    <main>
      <div class="toc">
        <center><b>Table of Content</b></center>
        <br />
        01: <u><a href="#head01">Class Variable</a><br /></u> 02:
        <u><a href="#head02">Method With Parameters</a><br /></u> 03:
        <u><a href="#head03">Methods With Return Type</a><br /></u> 04:
        <u><a href="#head04">Method Overloading</a><br /></u> 05:
        <u><a href="#head05">Passing Object as Parameter</a><br /></u> 05.01:
        <u><a href="#head0501">Static Fields and Methods</a><br /></u> 06:
        <u><a href="#head06">Array</a><br /></u> 06.01
        <u><a href="#head0601">Array Size Through Input</a><br /></u> 06.01
        <u><a href="#head0602">Example</a><br /></u> 06.01
        <u><a href="#head0603">Reusing Array Variable</a><br /></u> 06.01
        <u><a href="#head0604">Array Length</a><br /></u> 07:
        <u><a href="#head07">2-D Array</a><br /></u> 07.01:
        <u><a href="#head0700">for-each Loop</a><br /></u> 07.02:
        <u><a href="#head0701">Passing Array to the Method</a></u> 07.03:
        <u><a href="#head0702">How to Return an Array</a></u> 08:
        <u><a href="#head08">Command Line Argument</a><br /></u> 09:
        <u><a href="#head09">Inheritance</a><br /></u> 09.01:
        <u><a href="#head0901">Single Inheritance</a><br /></u> 09.02:
        <u><a href="#head0902">Multilevel Inheritance</a><br /></u> 09.03:
        <u><a href="#head0903">Hierarchical Inheritance</a><br /></u> 09.04:
        <u><a href="#head0904">Multiple Inheritance</a><br /></u> 09.05:
        <u><a href="#head0905">Hybrid Inheritance</a><br /></u> 10:
        <u><a href="#head10">Abstract Class</a><br /></u> 11:
        <u><a href="#head11">Polymorphism</a><br /></u> 11.01:
        <u><a href="#head1101">Method Overloading</a><br /></u> 12:
        <u><a href="#head12">Operator Overloading</a><br /></u> 13:
        <u><a href="#head13">Super</a><br /></u> 14:
        <u><a href="#head14">Questions</a><br /></u>
      </div>
      <div class="page">
        <h1 id="head01">Class Variable</h1>
        <br />
        <ul>
          <li>All variables are also known as instance variable.</li>
          <li>
            This is because of the fact that each instance or object has its own
            copy of values for the variables.
          </li>
          <li>
            Hence other use of the &quot;dot” operator is to initialise the
            value of variable for that instance
          </li>
        </ul>
        <br /><br />
        <h1 id="head02">Method With Parameters</h1>
        <br />
        <pre><code class="lang-JAVA">
  class prg {
    int n,n2,sum;
    
    public void take(int x,int y) {
      n=x; n2=y; 
    }
  
    public void sum() { 
      sum=n+n2; 
    }
  
    public void print() { 
      System.out.println("The Sum is"+sum); 
    }
  }
  
  class prg1 {
    public static void main(String args[]) { 
      prg obj=new
      prg();
      obj.take(10,15); 
      obj.sum(); 
      obj.print(); 
    }
  }
</code></pre>
        <br />
        <h1 id="head03">Methods With Return Type</h1>
        <br />
        <ul>
          <li>
            When method return some value that is the type of that method.
          </li>
          <li>
            For Example: some methods are with parameter but that method did not
            return any value that means type of method is void. And if method
            return integer value then the type of method is an integer
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
class Demo1 {
  int n, n2;
  public void take(int x, int y) {
    n = x;
    n = y;
  }
  public int process() {
    return (n + n2);
  }
}
class prg {
  public static void main(String args[]) {
    int sum;
    Demo1 obj = new Demo1();
    obj.take(15, 25);
    sum = obj.process();
    System.out.println("The sum is" + sum);
  }
}
</code></pre>
        <br /><br />
        <h1 id="head04">Method Overloading</h1>
        <br />
        <ul>
          <li>
            Method overloading means method name will be same but each method
            should be different parameter list.
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
class prg1 {
  int x = 5, y = 5, z = 0;
  public void sum() {
    z = x + y;
    System.out.println("Sum is " + z);
  }
  public void sum(int a, int b) {
    x = a;
    y = b;
    z = x + y;
    System.out.println("Sum is " + z);
  }
  public int sum(int a) {
    x = a;
    z = x + y;
    return z;
  }
}
class Demo {
  public static void main(String args[]) {
    prg1 obj = new prg1();
    obj.sum();
    obj.sum(10, 12);
    System.out.println(+obj.sum(15));
  }
}
</code></pre>
        <br /><br />
        <h1 id="head05">Passing Object as Parameter</h1>
        <br />
        <li>
          We have defined a method “take2” that declares an object named obj as
          parameter. We have passed ob to our method. The method “take2”
          automatically gets 3,7 as values for n and n2
        </li>
        <br />
        <pre><code class="lang-JAVA">
  class para123 {
    int n, n2, sum, mul;
    public void take(int x, int y) {
      n = x;
      n2 = y;
    }
    public void sum() {
      sum = n + n2;
      System.out.println("The Sum is" + sum);
    }
    public void take2(para123 obj) {
      n = obj.n;
      n2 = obj.n2;
    }
    public void multi() {
      mul = n * n2;
      System.out.println("Product is" + mul);
    }
  }
  class DemoPara {
    public static void main(String args[]) {
      para123 ob = new para123();
      ob.take(3, 7);
      ob.sum();
      ob.take2(ob);
      ob.multi();
    }
  }
</code></pre>
        <br /><br />
        <h4 id="head0501">Static Fields and Methods</h4>
        <br />
        <ul>
          <li>A static data field does not belong to any one object</li>
          <li>Also called a class variable</li>
          <li>
            Only one instance of the variable exists for all instances of the
            class
          </li>
          <li>Note that a static data field is not a constant (final)</li>
          <li><p>All instances of the class reference that one variable</p></li>
          <li>
            <p>
              Consider the need of a method that does not belong to an object of
              any type
            </p>
            <ul>
              <li>Examples</li>
              <li>A method to find the max or min of two or more numbers</li>
              <li>A square root method</li>
            </ul>
          </li>
          <li>
            When specified static, a method is still a member of the class
            <ul>
              <li>However, does not need an object as a prefix to the call</li>
            </ul>
          </li>
          <li>
            Call with the name of the class
            <ul>
              <li><code>int maximum = Math.max(2, 3);</code></li>
              <li><code>double root = Math.sqrt(4.2);</code></li>
            </ul>
          </li>
        </ul>
        <br /><br />
        <h1 id="head56"><code>this</code> keyword in Java</h1>
        <br />
        <ul>
          <li>
            <code>this</code> is a reference variable that refers to the current
            object.
          </li>
        </ul>
        <br />
        <pre><code class="lang-Java">
//Java code for using 'this' keyword to
//refer current class instance variables
class Test {
  int a;
  int b;
  // Parameterized constructor
  Test(int a, int b) {
    this.a = a;
    this.b = b;
  }
  void display() { //Displaying value of variables a
    and b
    System.out.println("a = " + a + " b = " +
      b);
  }
  public static void main(String[] args) {
    Test object = new Test(10, 20);
    object.display();
  }
}
</code></pre>
        <br /><br />
        <h1 id="head06">Array</h1>
        <br />
        <div class="images">
          <img src="assets/img/02java01.png" width="90%" />
        </div>
        <br />
        <ul>
          <li>Array is collection of related data items</li>
          <li>
            <strong>Declaring an Array</strong>:
            <ul>
              <li>
                Do not have to create an array while declaring array variable
              </li>
              <li><code>&lt;type&gt; [ ] variable_name;</code></li>
              <li><code>Double[ ] myList;</code></li>
              <li><code>double myList[ ];</code></li>
            </ul>
          </li>
          <li>Both syntaxes are equivalent</li>
          <li><p>No memory allocation at this point</p></li>
          <li>
            <p><strong>Defining an Array:</strong></p>
            <ul>
              <li><code>variable_name=new &lt;type&gt;[arraySize];</code></li>
              <li><code>Number = new int[5];</code></li>
              <li><code>Mylist = new int[10];</code></li>
              <li>
                It creates an array using new <code>dataType[arraySize];</code>
              </li>
              <li>
                It assigns the reference of the newly created array to the
                variable <code>variable_name</code>
              </li>
              <li><code>dataType array_name[ ] = {list of values};</code></li>
              <li><code>Int a [ ]={1,2,3,4,5,6,7,};</code></li>
              <li>Array index starts from 0 to arraySize-1</li>
            </ul>
          </li>
        </ul>
        <br /><br />
        <h4 id="head0601">Array Size Through Input</h4>
        <br />
        <pre><code class="lang-JAVA">
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class ArraySizeInput {
    public static void main(String[] args) throws Exception {
        BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
        String inData;
        int num;
        System.out.print("Enter a Size for Array:");
        inData = stdin.readLine();
        num = Integer.parseInt(inData);
        long[] primes = new long[num];
        System.out.println("Array Length = " + primes.length);
    }
}

// OUTPUT
// Enter a size for array: 4
// Array Length = 4
</code></pre>
        <br /><br />
        <h4 id="head0602">Example</h4>
        <br />
        <pre><code class="lang-JAVA">
public class TestArray {
  public static void main(String[] args) {
    double[] myList = {
      1.9,
      2.9,
      3.4,
      3.5
    };
    // Print all the array elements
    for (double element: myList) {
      System.out.println(element);
    }
  }
}

// OUTPUT
// 1.9
// 2.9
// 3.4
// 3.5
</code></pre>
        <br /><br />
        <h4 id="head0603">Reusing Array Variable</h4>
        <br />
        <pre><code class="lang-JAVA">
long[] primes = new long[20];
primes[0] = 2;
primes[1] = 3;
System.out.println(primes[0]);
System.out.println(primes[1]);

// Output:
// 2
// 3
</code></pre>
        <br /><br />
        <h4 id="head0604">Array Length</h4>
        <br />
        <ul>
          <li>Refer to array length using <code>length()</code> method</li>
          <li>
            If number of elements in the array are changed, JAVA will
            automatically change the length attribute!
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
long[ ] primes = new long[20];
System.out.println(primes.length);

// OUTPUT
// 20
</code></pre>
        <br /><br />
        <pre><code class="lang-JAVA">
public class MinArray {
    public static void main(String[] args) {
        int[] array = { 20, 19, 1, 5, 71, 27, 19, 95 };
        int min = array[0];
        for (int index = 1; index < array.length; index++) {
            if (array[index] < min) {
                min = array[index];
            }
        }
        System.out.println("The minimum of this array is: " + min);
    }
}
</code></pre>
        <br /><br />
        <h1 id="head07">2 Dimensional Array</h1>
        <br />
        <ul>
          <li>
            Representing 2D arrays
            <ul>
              <li><code>Int myarray[][];</code></li>
              <li><code>Myarray = new int[3][4];</code></li>
              <li><code>Int myarray [][] = new int[3][4];</code></li>
            </ul>
          </li>
          <li>
            Example
            <ul>
              <li>
                <code>Int myarray[2][3]={0,0,0,1,1,1};</code> 2 columns and 3
                rows
              </li>
            </ul>
          </li>
        </ul>
        <br /><br />
        <h1 id="head0700">for-each Loop</h1>
        <br />
        <ul>
          <li>
            The Java for-each loop or enhanced for loop is introduced since J2SE
            5.0.
          </li>
          <li>
            It provides an alternative approach to traverse the array or
            collection in Java.
          </li>
          <li>
            It is mainly used to traverse the array or collection elements.
          </li>
          <li>
            The advantage of the for-each loop is that it eliminates the
            possibility of bugs and makes the code more readable.
          </li>
          <li>
            It is known as the for-each loop because it traverses each element
            one by one.
          </li>
          <li>
            The Java for-each loop traverses the array or collection until the
            last element. For each element, it stores the element in the
            variable and executes the body of the for-each loop.
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
for(data_type variable : array | collection) { 
	//body of for-each loop 
}
</code></pre>
        <br /><br />
        <h4 id="head0701">Passing Array to the Method</h4>
        <br />
        <ul>
          <li>
            Arrays can be passed to other methods just like how you pass
            primitive data type’s arguments.
          </li>
          <li>
            To pass an array as an argument to a method, you just have to pass
            the name of the array without square brackets.
          </li>
          <li>
            The method prototype should match to accept the argument of the
            array type. <code>void method_name (int [] array);</code>
          </li>
          <li>
            This means <code>method_name</code> will accept an array parameter
            of type <code>int</code>. So if you have an int array named
            <code>myarray</code>, then you can call the above method as follows:
            <code>method_name (myarray);</code>
          </li>
        </ul>
        <br /><br />
        <h4 id="head0702">How to Return an Array</h4>
        <br />
        <ul>
          <li>
            Apart from all the primitive types that you can return from Java
            programs, you can also return references to arrays.
          </li>
          <li>
            While returning a reference to an array from a method, you should
            keep in mind that:
          </li>
          <li>
            The data type that returns value should be specified as the array of
            the appropriate data type.
          </li>
          <li>
            The returned value from a method is the reference to the array.
          </li>
          <li>
            The array is returned from a method in the cases where you need to
            return multiple values of the same type from a method.
          </li>
          <li>
            This approach becomes useful as Java doesn’t allow returning
            multiple values.
          </li>
        </ul>
        <br /><br />
        <h1 id="head08">Command Line Argument</h1>
        <br />
        <ul>
          <li>
            The java command-line argument is an argument i.e. passed at the
            time of running the java program.
          </li>
          <li>
            The arguments passed from the console can be received in the java
            program and it can be used as an input.
          </li>
          <li>
            So, it provides a convenient way to check the behaviour of the
            program for the different values.
          </li>
          <li>
            You can pass N (1,2,3 and so on) numbers of arguments from the
            command prompt.
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
class CommandLineExample {
  public static void main(String args[]) {
    System.out.println("Your first argument is: " + args[0]);
  }
}
</code></pre>
        <br />
        <ul>
          <li>Compile &gt; <code>javac CommandLineExample.java</code></li>
          <li>Run &gt; <code>java CommandLineExample sonoo</code></li>
          <li>Output &gt; <code>Your first argument is: sonoo</code></li>
        </ul>
        <br /><br />
        <h1 id="head09">Inheritance</h1>
        <br />
        <ul>
          <li>
            Inheritance is an important pillar of <strong>OOP</strong>(Object
            Oriented Programming). It is the mechanism in java by which one
            class is allow to inherit the features(fields and methods) of
            another class.
          </li>
          <li>
            <strong>Super Class:</strong> The class whose features are inherited
            is known as super class(or a base class or a parent class).
          </li>
          <li>
            <strong>Sub Class:</strong> The class that inherits the other class
            is known as sub class(or a derived class, extended class, or child
            class). The subclass can add its own fields and methods in addition
            to the superclass fields and methods.
          </li>
          <li>
            <strong>Reusability</strong>: Inheritance supports the concept of
            “reusability”, i.e. when we want to create a new class and there is
            already a class that includes some of the code that we want, we can
            derive our new class from the existing class. By doing this, we are
            reusing the fields and methods of the existing class.
          </li>
          <li>The keyword used for inheritance is <code>extends</code>.</li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
class derived-class extends base-class {
	//methods and fields
}
</code></pre>
        <br /><br />
        <h4 id="head0901">Single Inheritance</h4>
        <br />
        <div class="images">
          <img src="assets/img/02java02.png" width="90%" />
        </div>
        <li>
          In single inheritance, a single subclass is extended from a single
          superclass and inherits its properties.
        </li>
        <br />
        <pre><code class="lang-JAVA">
class A {
  int x, y;
  void getdata(int a, int b) {
    x = a;
    y = b;
  }
  int add() {
    System.out.println(“Superclass Method”);
    return (x + y);
  }
}
class B extends A {
  int mult() {
    System.out.println(“Sub - class Method”);
    return (x * y);
  }
}
class Test {
  public static void main(String args[]) {
    B obj = new B();
    int add, mult;
    obj.getdata(5, 3);
    add = obj.add();
    mult = obj.mult();
    System.out.println(“Addition” + add);
    System.out.println(“Multiplication” + mult);
  }
}
</code></pre>
        <br /><br />
        <h4 id="head0902">Multilevel Inheritance</h4>
        <br />
        <div class="images">
          <img src="assets/img/02java03.png" width="90%" />
        </div>
        <li>
          In multilevel inheritance, a child class is derived from a parent
          class and that child class further acts as a parent class and is used
          to derive another child class.
        </li>
        <br />
        <pre><code class="lang-JAVA">
class one {
  public void print() {
    System.out.println(“hi ");
    }
  }
  class two extends one {
    public void print1() {
      System.out.println(“hello ");
      }
    }
    class three extends two {
      public void print2() {
        System.out.println(“hi ");
        }
      }
      // Drived class
      public class Main {
        public static void main(String[] args) {
          three g = new three();
          g.print();
          g.print1();
          g.print2();
        }
      }
</code></pre>
        <br /><br />
        <h4 id="head0903">Hierarchical Inheritance</h4>
        <br />
        <div class="images">
          <img src="assets/img/02java04.png" width="90%" />
        </div>
        <li>
          In Hierarchical Inheritance, one superclass is used to derive more
          than one subclass or we can say that multiple subclasses extend from
          a single superclass.
        </li>
        <br />
        <pre><code class="lang-JAVA">
class One {
  int x = 10, y = 20;
  void disp() {
    System.out.println(“Method of class One”);
    System.out.println(“Value of X” + x);
    System.out.println(“Value of Y” + y);
  }
}
class Two extends One {
  void add() {
    System.out.println(“Method of class Two”);
    System.out.println(“Addition: ”+(x + y));
  }
}
class Three extends One {
  void mul() {
    System.out.println(“Method of class Three”);
    System.out.println(“Multiplication: ”+(x * y));
  }
}
class Test {
  public static void main(String args[]) {
    Two obj1 = new Two();
    Three obj2 = new Three();
    obj1.disp();
    obj1.add();
    obj2.mul();
  }
}
</code></pre>
        <br /><br />
        <h4 id="head0904">Multiple Inheritance</h4>
        <br />
        <div class="images">
          <img src="assets/img/02java05.png" width="90%" />
        </div>
        <li>
          In Multiple Inheritance, one subclass is derived from more than one
          superclass.
        </li>
        <li>
          Java doesn't support multiple inheritances because of high complexity
          and logic issues but as an alternative, we can implement multiple
          inheritances in Java using interfaces.
        </li>
        <br />
        <pre><code class="lang-JAVA">
class Student {
  int m1, m2;
  void getmarks(int x, int y) {
    m1 = x;
    m2 = y;
  }
  void putmarks() {
    System.out.println(“First” + m1);
    System.out.println(“Second” + m2);
  }
}
interface sport {
  int sp = 6;
  void spmarks();
}
class Result extends Student implements
Sport {
  int total;
  public void spmarks() {
    System.out.println(“Sport Mark” + sp);
  }
  void disp() {
    putmarks();
    spmarks();
    total = m1 + m2 + sp;
    System.out.println(“Total” + total);
  }
}
class Test {
  public static void main(String args[]) {
    Result obj = new Result();
    obj.getmarks(80, 60);
    obj.disp();
  }
}
</code></pre>
        <br /><br />
        <h4 id="head0905">Hybrid Inheritance</h4>
        <br />
        <div class="images">
          <img src="assets/img/02java06.png" width="90%" />
        </div>
        <li>
          It is a mix of two or more of the above types of inheritance. Since
          java doesn’t support multiple inheritance with classes, the hybrid
          inheritance is also not possible with classes. In java, we can achieve
          hybrid inheritance only through Interfaces.
        </li>
        <br />
        <pre><code class="lang-JAVA">
class C {
  public void display() {
    System.out.println("C");
  }
}

class A extends C {
  public void display() {
    System.out.println("A");
  }
}

class B extends C {
  public void display() {
    System.out.println("B");
  }
}

class D extends A {
  public void display() {
    System.out.println("D");
  }
}

class Main {
  public static void main(String args[]) {
    D obj = new D();
    obj.display();
  }
}
</code></pre>
        <br /><br />
        <h1 id="head10">Abstract Class</h1>
        <br />
        <ul>
          <li>
            A class that is declared using “abstract” keyword is known as
            abstract class. It can have abstract methods(methods without body)
            as well as concrete methods (regular methods with body).
          </li>
          <li>
            A normal class(non-abstract class) cannot have abstract methods.
          </li>
          <li>
            An abstract class can not be instantiated, which means you are not
            allowed to create an object of it
          </li>
        </ul>
        <br />
        <p><strong>Why we need an Abstract Class?</strong></p>
        <br />
        <ul>
          <li>
            Suppose, We have a class Animal that has a method sound() and the
            subclasses of it like Dog, Lion, Horse, Cat etc.
          </li>
          <li>
            Since the animal sound differs from one animal to another, there is
            no point to implement this method in parent class.
          </li>
          <li>
            This is because every child class must override this method to give
            its own implementation details, like Lion class will say “Roar” in
            this method and Dog class will say “Woof”.
          </li>
          <li>
            So when we know that all the animal child classes will override this
            method, then there is no point to implement this method in parent
            class.
          </li>
          <li>
            Thus, making this method abstract would be the good choice as by
            making this method abstract we force all the sub classes to
            implement this method.
          </li>
          <li>
            Since the Animal class has an abstract method, you must need to
            declare this class abstract.
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
abstract class Animal { //abstract method
  public abstract void sound();
}
public class Dog extends Animal //Dog class
extends Animal class {
  public void sound() {
    System.out.println("Woof");
  }
  public static void main(String args[]) {
    Dog obj = new Dog();
    obj.sound();
  }
}
</code></pre>
        <br />
        <div class="images">
          <img src="assets/img/02java07.png" width="90%" />
        </div>
        <br />
        <p>
          <strong>Why can’t we create the object of an abstract class?</strong>
        </p>
        <br />
        <ul>
          <li>
            Because these classes are incomplete, they have abstract methods
            that have no body.
          </li>
          <li>
            There would be no actual implementation of the method to invoke.
          </li>
          <li>
            An abstract class is like a template, so you have to extend it and
            build on it before you can use it.
          </li>
          <li>
            An abstract class has no use until unless it is extended by some
            other class.
          </li>
        </ul>
        <br />
        <p><strong>Keypoints:</strong></p>
        <br />
        <ul>
          <li>
            If you declare an abstract method in a class then you must declare
            the class abstract as well. you can’t have abstract method in a
            concrete class. If a class is not having any abstract method then
            also it can be marked as abstract.
          </li>
          <li>It can have non-abstract method (concrete) as well.</li>
          <li>
            The subclass of abstract class in java must implement all the
            abstract methods unless the subclass is also an abstract class.
          </li>
          <li>
            We can access the static attributes and methods of an abstract class
            using the reference of the abstract class. For example,
            <code>Animal.staticMethod();</code>
          </li>
        </ul>
        <br />
        <p><strong>Difference between Abstract Class and Interface</strong></p>
        <br />
        <table>
          <thead>
            <tr>
              <th>Abstract Class</th>
              <th>Interface</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                Abstract class can have abstract and non-abstract methods.
              </td>
              <td>Interface can have only abstract methods.</td>
            </tr>
            <tr>
              <td>Abstract class doesn&#39;t support multiple inheritance.</td>
              <td>Interface supports multiple inheritance.</td>
            </tr>
            <tr>
              <td>
                Abstract class can have final, non-final, static and non-static
                variables.
              </td>
              <td>Interface has only static and final variables.</td>
            </tr>
            <tr>
              <td>
                Abstract class can provide the implementation of interface.
              </td>
              <td>
                Interface can&#39;t provide the implementation of abstract
                class.
              </td>
            </tr>
            <tr>
              <td>The abstract keyword is used to declare abstract class.</td>
              <td>The interface keyword is used to declare interface.</td>
            </tr>
            <tr>
              <td>
                An abstract class can be extended using keyword
                &quot;extends&quot;.
              </td>
              <td>
                An interface can be implemented using keyword
                &quot;implements&quot;.
              </td>
            </tr>
            <tr>
              <td>
                A Java abstract class can have class members like private,
                protected, etc.
              </td>
              <td>Members of a Java interface are public by default.</td>
            </tr>
            <tr>
              <td>
                public abstract class Shape{<br />
                &nbsp; &nbsp; &nbsp;public abstract void draw();<br />}
              </td>
              <td>
                public interface Drawable{<br />
                &nbsp; &nbsp; &nbsp;void draw();<br />}
              </td>
            </tr>
          </tbody>
        </table>
        <br />
        <p><strong>When to use Abstract Class and Abstract Method?</strong></p>
        <br />
        <ul>
          <li>
            Abstract methods are usually declared where two or more subclasses
            are expected to do a similar thing in different ways through
            different implementations.
          </li>
          <li>
            These subclasses extend the same Abstract class and provide
            different implementations for the abstract methods.
          </li>
          <li>
            Abstract classes are used to provide implementation details of the
            abstract class in the subclass.
          </li>
        </ul>
        <br /><br />
        <h1 id="head11">Polymorphism</h1>
        <br />
        <ul>
          <li>
            The word polymorphism means having many forms. In simple words, we
            can define polymorphism as the ability of a message to be displayed
            in more that one form.
          </li>
          <li>
            Real life example of polymorphism: A person at the same time can
            have different characteristic. Like a man at the same time is a
            father, a husband, an employee. So the same person posses different
            behaviour in different situations. This is called polymorphism.
          </li>
          <li>
            Polymorphism is considered as one of the important features of
            Object Oriented Programming. Polymorphism allows us to perform a
            single action in different ways. In other words, polymorphism allows
            you to define one interface and have multiple implementations. The
            word “poly” means many and “morphs” means forms, So it means many
            forms.
          </li>
          <li>
            In Java polymorphism is mainly divided into two types:
            <ul>
              <li><strong>Runtime Polymorphism</strong></li>
              <li>
                <strong>Compile time polymorphism</strong>: It is also known as
                static polymorphism. This type of polymorphism is achieved by
                function overloading or operator overloading.
              </li>
            </ul>
          </li>
        </ul>
        <br /><br />
        <h4 id="head1101">Method Overloading</h4>
        <br />
        <ul>
          <li>
            When there are multiple functions with same name but different
            parameters then these functions are said to be overloaded. Functions
            can be overloaded by change in number of arguments or/and change in
            type of arguments.
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
// By using different types of arguments
class MultiplyFun {
  // Method with 2 parameter
  int Multiply(int a, int b) {
    return a * b;
  }
  // Method with the same name but 2 double parameter
  double Multiply(double a, double b) {
    return a * b;
  }
}
class Main {
  public static void main(String[] args) {
    MultiplyFun f = new MultiplyFun();
    System.out.println(f.Multiply(2, 4));
    System.out.println(f.Multiply(5.5, 6.3));
  }
}
</code></pre>
        <br /><br />
        <pre><code class="lang-JAVA">
// By using different numbers of arguments
class MultiplyFun {
  // Method with 2 parameter
  int Multiply(int a, int b) {
    return a * b;
  }
  // Method with the same name but 3 parameter
  int Multiply(int a, int b, int c) {
    return a * b * c;
  }
}
class Main {
  public static void main(String[] args) {
    MultiplyFun f = new MultiplyFun();
    System.out.println(f.Multiply(2, 4));
    System.out.println(f.Multiply(2, 7, 3));
  }
}
</code></pre>
        <br />
        <h1 id="head12">Operator Overloading</h1>
        <br />
        <ul>
          <li>
            Java also provide option to overload operators. For example, we can
            make the operator (‘+’) for string class to concatenate two strings.
            We know that this is the addition operator whose task is to add two
            operands.
          </li>
          <li>
            So a single operator ‘+’ when placed between integer operands, adds
            them and when placed between string operands, concatenates them.
          </li>
          <li>
            In java, Only “+” operator can be overloaded:
            <ul>
              <li>To add integers</li>
              <li>To concatenate strings</li>
            </ul>
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
class OperatorOVERDDN {
  void operator(String str1, String str2) {
    String s = str1 + str2;
    System.out.println("Concatinated String - " +
      s);
  }
  void operator(int a, int b) {
    int c = a + b;
    System.out.println("Sum = " + c);
  }
}
class Main {
  public static void main(String[] args) {
    OperatorOVERDDN obj = new
    OperatorOVERDDN();
    obj.operator(2, 3);
    obj.operator(“a ", “b");
  }
}
</code></pre>
        <br />
        <ul>
          <li>
            <strong>Runtime polymorphism:</strong> It is also known as
            <strong>Dynamic Method Dispatch</strong>. It is a process in which a
            function call to the overridden method is resolved at Runtime. This
            type of polymorphism is achieved by Method Overriding.
          </li>
          <li>
            <strong>Method overriding</strong>, on the other hand, occurs when a
            derived class has a definition for one of the member functions of
            the base class. That base function is said to be overridden.
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
class Parent {
  void Print() {
    System.out.println("parent class");
  }
}
class subclass1 extends Parent {
  void Print() {
    System.out.println("subclass1");
  }
}
class subclass2 extends Parent {
  void Print() {
    System.out.println("subclass2");
  }
}
class TestPolymorphism3 {
  public static void main(String[] args) {
    Parent a;
    a = new subclass1();
    a.Print();
    a = new subclass2();
    a.Print();
  }
}
  </code></pre>
        <br /><br />
        <h1 id="head13">Super</h1>
        <br />
        <ul>
          <li>
            The super keyword in java is a reference variable that is used to
            refer parent class objects.
          </li>
          <li>
            The keyword “super” came into the picture with the concept of
            Inheritance.
          </li>
          <li>Uses of super keyword</li>
          <li>
            To call methods of the superclass that is overridden in the
            subclass.
          </li>
          <li>
            To access attributes (fields) of the superclass if both superclass
            and subclass have attributes with the same name.
          </li>
          <li>
            To explicitly call superclass no-arg (default) or parameterized
            constructor from the subclass constructor.
          </li>
          <li>
            <strong>Use of Super with method:</strong>
            <ul>
              <li>
                This is used when we want to call parent class method. So
                whenever a parent and child class have same named methods then
                to resolve ambiguity we use super keyword.
              </li>
            </ul>
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
/* Base class Person */
class Person {
  void message() {
    System.out.println("This is person class");
  }
}
class Student extends Person
/* Subclass Student */
{
  void message() {
    System.out.println("This is student class");
  }
  void display() // Note that display() is
  only in Student class {
    message(); // will invoke or call current
    class message() method
    super.message(); // will invoke or call
    parent class message() method
  }
}
class Test /* Driver program to test */ {
  public static void main(String args[]) {
    Student s = new Student();
    s.display(); // calling display() of
    Student
  }
}
</code></pre>
        <br />
        <ul>
          <li>
            <strong>Use of Super with Constructor:</strong>
            <ul>
              <li>
                Super keyword can also be used to access the parent class
                constructor. One more important thing is that, ‘’super’ can call
                both parametric as well as non parametric constructors depending
                upon the situation
              </li>
            </ul>
          </li>
        </ul>
        <br />
        <pre><code class="lang-JAVA">
class Person {  
// Superclass Person
    Person() {
        System.out.println("Person class Constructor");
    }
}

class Student extends Person {  
// Subclass Student extending Person
    Student() {
        super();
        System.out.println("Student class Constructor");
    }
}

class Test {  
// Driver class to test
    public static void main(String[] args) {
        Student s = new Student();
    }
}
  </code></pre>
        <br /><br />
        <h1 id="head14">Questions</h1>
        <br />
        <ol>
          <li>What is Class Variable? Define all the Methods of it.</li>
          <li>What is <code>this</code> keyword ? Explain it with example.</li>
          <li>
            What is an Array? Explain one dimensional and two dimensional.
          </li>
          <li>Explain <code>for each</code> loop with example.</li>
          <li>
            Explain the following
            <ol>
              <li>Passing Array to the method.</li>
              <li>How to return an array?</li>
              <li>Command line argument.</li>
            </ol>
          </li>
          <li>
            What is Inheritance? Explain it with type with diagram and its code.
          </li>
          <li>What is an Abstract Class? Why we need an Abstract Class?</li>
          <li>
            Write down the difference between Abstract Class and Interface.
          </li>
          <li>
            What is Polymorphism? How many type of polymorphism? Explain in
            detail. (Method Overloading, Operator Overloading, Method
            Overriding)
          </li>
          <li>
            What is <code>Super</code> keyword? Explain it with its method.
          </li>
          <li>Explain use of <code>Super</code> keyword with constructor.</li>
        </ol>
        <br />
      </div>
    </main>
    <a class="dlbtn" href="assets/pdfs/Java02.pdf"
      ><img src="assets/img/download.png" height="50px"
    /></a>
    <div class="end">
      <div class="footer">
        <p>
          Made by <a href="../about.html"><u>SOU Student</u></a> For SOU
          Students
        </p>
      </div>
    </div>
    <script src="../assets/js/global.js"></script>
    <script src="assets/js/prism.js"></script>
  </body>
</html>
